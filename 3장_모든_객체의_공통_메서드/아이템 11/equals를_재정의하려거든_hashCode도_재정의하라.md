## item 11

### equals를 재정의하려거든 hashCode도 재정의하라

---

### 🙋‍♀️ 왜 함께 재정의해줘야 하나요?

`hashCode` 일반 규약을 어기게 되어 해당 클래스의 인스턴스를 `HashMap`이나 `HashSet` 같은 컬렉션의 원소로 사용할 때 문제를 일으킬 것이기 때문입니다.

---

### 🙋‍ hashCode 의 일반 규약은 무엇인가요?
다음은 규약 중 일부입니다.
#### 1. equals 비교에 사용되는 핵심 필드가 달라지지 않았다면, hashCode 메서드는 몇 번을 호출해도 일관되게 항상 같은 값을 반환해야 합니다.
#### 2. equals 비교를 통해 같다고 판명된 객체라면, 각 객체의 hashCode는 똑같은 값을 반환해야 합니다.
#### 3. equals 비교를 통해 다르다고 판단된 값이라도, 서로 다른 값을 반환할 필요는 없습니다. 다만!! 다른 객체라면 다른 값을 반환하는 게 해시테이블의 성능이 좋아집니다.

---

### 🙌 hashCode 재정의를 잘못한다면 2번 조항에서 문제가 생깁니다.
간단히 말하자면, `equals`에서는 같은 객체라고 판단했으나 `hashCode`에 대한 재정의가 잘못되어서 `HashMap`이나 `HashSet`에서 같은 원소로 판별되지 않는 문제가 생긴다는 것입니다.

`equals`는 물리적으로 다른 두 객체를 논리적으로 같은 객체라고 판단할 수 있지만 `hashCode`를 재정의하지 않는다면 `hashCode`는 이를 모를 것이기 때문입니다.

---

### 🙋‍♀️ 그럼 hashCode는 어떻게 구현하는 게 올바른 방법인가요?

#### 최악의 방법
```java
@Override
public int hashCode(){
    return 42;
}
```
`동치인` 모든 객체에서 똑같은 해시코드를 반환하기에 적법합니다.
문제는 `동치가 아닌` 객체에서도 똑같은 해시코드를 반환하기 때문에 생깁니다.
결과적으로 해시테이블의 버킷 하나에 모두 담겨 연결 리스트처럼 동작하고, 평균 수행 시간이 0(1) > O(n)으로 느려져서 객체가 많아지면 도저히 쓸 수 없게 됩니다.

---

#### 좋은 방법
```java
@Override
public int hashCode(){
    int result = Short.hashCode(areaCode);
    result = 31 * result + Short.hashCode(prefix);
    result = 31 * result + Short.hashCode(lineNum);
    return result;
}
```
좋은 해시 함수라면 서로 다른 인스턴스에 다른 해시코드를 반환합니다.(3번 조항)
##### 1) int 변수 result를 선언한 후 `첫번째 핵심 필드`를 단계 `2.a 방식으로 계산`한 해시코드로  초기화합니다.
##### 2) 해당 객체의 나머지 핵심 필드에 대한 작업을 수행합니다.
| 필드 형식 및 조건               | 처리 방식                                                                        |
|--------------------------|------------------------------------------------------------------------------|
| 기본 타입                    | `Type.hashCode(f)`                                                           |
| 참조 타입  + equals 재귀 호출 처리 | 해당 필드의 `hashCode` 재귀 호출 / 필드의 표준형 제작                                         | 
| 배열                       | 배열의 참조값이 아닌 각 핵심 원소에 대한 값을 처리하며 갱신(누적) / 모든 원소가 핵심 원소라면, Arrays.hashCode를 사용 | 

#### 3) 계산한 해시코드로 result 갱신
#### 4) result 반환
#### 5) 동치인 인스턴스에 대해 똑같은 해시 코드를 반환하는지 테스트
#### 6) 단위 테스트 작성

---

✔ 추가 주의점
#### 1) null, 핵심 원소 X 배열 > 상수, 특히 0으로 처리하기
#### 2) 파생 필드는 계산에서 제외하기
#### 3) equals 비교에 사용되지 않은 필드 반드시 제외하기
#### 4) result와 곱하는 수는 짝수이거나 오버플로가 발생하면 안됨(31 추천)
#### 5) 성능 개선 때문에 핵심 필드 생략을 해선 안됨, 되레 속도가 느려질 가능성 있음

---

✔ 추가 개선 사항
#### 1) 코드를 줄이기 위해 hash 메서드를 사용할 수 있으나 성능에 민감하지 않은 상황에서만 사용하기
#### 2) 클래스가 불변, 해시코드를 계산하는 비용이 크다면 캐싱을 고려(해당 타입의 객체가 해시의 키로 사용)
#### 3) 해시의 키로 사용되지 않는다면,지연 초기화 전략 사용
#### 4) hashCode가 반환하는 값의 생성 규칙을 API 사용자에게 자세히 공표하지 말기

이에 따라서 핵심 필드 3개만을 사용하여 간단히 계산이 가능해졌습니다.

---
